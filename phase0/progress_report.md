# Progress Report

## Summary of Project
We are creating a password manager that will allow multiple users to securely store their data in a designated account. Each user is associated with an account that must be authenticated with a password before signing in. Each account allows the user to create, search for, edit, and delete entries of their login information. In addition, the user can create notes, contacts, and store identification with the same functionality as the login information entries. 

Within the CRC model, there are six entity classes. Account is an entity class which represents an account associated with a user. PrivateInfo is also an abstract entity class, and it is the parent class of the other four entity classes, which include: LogIn, Note, ID, and Contact. These subclasses each represent a type of entry that can be associated with an account. 

The Use Case Classes include AccountManager, PrivateInfoManager, EncryptMaster, and EncryptPrivInfo. AccountManager adds functionality to Account objects by facilitating their creation, deletion, and logins. This manager also interacts with the EncryptMaster Use Case by using SHA3-256 to encrypt the password associated with an Account. PrivateInfoManager manages the PrivateInfo objects for each Account, and adds functionality such as searching or adding new PrivateInfo objects. This manager also interacts with the EncryptPrivInfo Use Case to encrypt and decrypt PrivateInfo objects using the Blowfish API. 

At the Interface Adapter Level, there is the Controller class. This class processes the input from UIMain, and assigns it to the appropriate use case of AccountManager or PrivateInfoManager.
 
The outer layer of the program includes the UIMain class and the PasswordManagerProgram class. UIMain is responsible for receiving input and output from the user. It may be necessary as this project expands to a GUI to separate this class into multiple classes to follow the Single Responsibility Principle. PasswordManagerProgram is the class where the main method is run from. 

The current state of the skeleton code allows the user to complete one typical scenario. The user starts by creating an account. They will be prompted to enter a username, password, and a key that is used for encryption of passwords, notes, etc. Then, the user can add an LogIn or choose to view their “vault”, which is a collection of all the user’s saved PrivateInfo’s. When the user is finished, they can log out, which will end the program. These commands are facilitated with prompts from the command line that tell the user what strings to input to execute certain commands.


The current skeleton generally follows the structure of the CRC cards, and the main method is run from PasswordManagerProgram. Please note that there are various discrepancies between the skeleton and the CRC cards at this time. For example, the main method in the skeleton is located in a controller class, but the CRC cards place them in a driver class. This is because during the implementation of the skeleton code, our group reevaluated our design decisions and found some flaws in our original design that violated Clean Architecture. The CRC cards have been updated to reflect these changes, and these changes will be reflected in the code as we continue the project. Furthermore, the skeleton code does not preserve data after quitting, as all data is currently being stored in memory. 

## Open Questions
One of the main questions that our group is working on is how to balance security and ease of use. For example, the encryption algorithm the program uses requires a key to encrypt the private data. As of right now, the key is being stored in the program, but this is a significant security flaw, since if an outsider were to gain access to the key, they would be able to decrypt all of the PrivateData objects. The program could ask the user to memorize the key they have created, but this would be undesirable from a user perspective because it requires more memorization. 

## What Has Worked
Our group has noticed that ensuring the entity classes are not dependent on any of the outer layers has worked well when implementing the code. For example, the PrivateInfo class does not depend on any other classes. PrivateInfoManager depends on PrivateInfo, so when we decided to change the PrivateInfoManager class by changing the info attribute from an ArrayList to an ArrayList of ArrayLists, this did not cause a conflict. 

Another design aspect that has proven to be useful is the utilization of inheritance with regards to PrivateInfo and its subclasses. This has allowed for polymorphism within the skeleton code. For example, in PrivateInfoManager, we defined the attribute vault, which stores PrivateInfo objects, and this allows us to store any combination of LogIns, IDs, Notes, or Contacts, in the vault.  

## Individual Contributions and Plans
The project domain, specification, and the layout of the CRC model was created through collaboration with the whole group. Patricia has been writing the specification and progress report. She plans to work on implementing the functions in PrivateInfoManager. Kelian has been researching various encryption methods and implemented the encryption classes. He plans to continue researching how to better implement the encryption. Hayk and Yousef have been programming the majority of the skeleton code, and they plan on implementing the sign in and out features for Accounts. Ryan has been polishing the CRC Cards and plans on implementing the classes responsible for reading and writing .txt files so that users can save their data after closing the program. Cliff has been researching on the scrypt key derivation function, and ensured that the encryption classes are forward-compatible with their encryption method. He plans to work on implementing the user interface. 
