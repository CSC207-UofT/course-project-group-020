###Phase 2 Design Document


###Specification

The password manager is a multi-user application that securely stores and retrieves sensitive data for its accounts. The user can create new accounts, sign in to an account, and sign out of an account, and delete accounts. To create a new account, the user must set a username and a master password. The password is salted and hashed (one-way encrypted) as a security measure. Each account can store entries of login information, notes, contacts, and/or identification information. The entries in each account are private to the other accounts and are also only accessible to the user when they are signed in. Each entry is stored in our program but encrypted using Blowfish, a symmetric block cipher. It is encrypted by the plaintext of the master password of the given account which is unattainable for developers. The encrypted entry is stored in a serialized bin file located at a specified file path given by the user.
When the user is creating a new login entry, the application gives the user the option to generate a strong password based on an algorithm developed in-file. The user can access the entries they have stored through the main menu of the application, which displays all the entries of the data that the manager is currently storing. The entry is accessed by decrypting the ciphertext from the serialized bin file and displayed for the user. Furthermore, any given entry of any type can be also edited and deleted by the user. An exception to this is when the user is accessing login information. In that case, the password is displayed in asterisks but it can be revealed by clicking the monkey icon.


###Major Design Changes

One major change that we decided on occurred when we realized an issue with Clean Architecture in our design. The issue was that AccountController was acting as both a controller and a use case when it was supposed to only act as a controller. For example, when AccountController received a request to create a new account, it would create an instance of the entity class Account, and then serialize it. This also violated Clean Architecture because a class in the Interface Adapters Level was directly dependent on an entity class. To fix this issue, we had the controller create instances of AccountManager. And through AccountManager it was allowed to perform its desired actions. We also implemented a PrivateInfo Factory, which creates instances of PrivateInfo, such as LogIns, Notes, Contacts, and Ids, which help the controller class to adhere to the dependency rules of clean architecture. Furthermore, PrivateInfoManager was removed as it was deemed useless and bloated the structure of our program. Its methods were either completely removed or rather, moved into AccountManager. And Private info instances were given a unique ID using Javaâ€™s built-in UUID feature, which allowed for easier communication between frontend, spring, and backend.

